/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/assets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Asset
         * @description Image typed files can be dynamically resized and transformed to fit any need.
         */
        get: operations["getAsset"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retrieve a Temporary Access Token
         * @description Retrieve a Temporary Access Token
         */
        post: operations["login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Token
         * @description Refresh a Temporary Access Token.
         */
        post: operations["refresh"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Log Out
         * @description Log Out
         */
        post: operations["logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/password/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request a Password Reset
         * @description Request a reset password email to be send.
         */
        post: operations["passwordRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/password/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset a Password
         * @description The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         */
        post: operations["passwordReset"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/oauth": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List OAuth Providers
         * @description List configured OAuth providers.
         */
        get: operations["oauth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/oauth/{provider}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Authenticated using an OAuth provider
         * @description Start OAuth flow using the specified provider
         */
        get: operations["oauthProvider"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/server/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * System Info
         * @description Perform a system status check and return the options.
         */
        get: operations["serverInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/server/ping": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Ping
         * @description Ping, pong. Ping.. pong.
         */
        get: operations["ping"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Files
         * @description List the files.
         */
        get: operations["getFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/files/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Files
         * @description Retrieve a single file by unique identifier.
         */
        get: operations["getFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Flows
         * @description Get all flows.
         */
        get: operations["getFlows"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Flow
         * @description Retrieve a single flow by unique identifier.
         */
        get: operations["getFlow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Webhooks
         * @description Get all webhooks.
         */
        get: operations["getWebhooks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhooks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Webhook
         * @description Retrieve a single webhook by unique identifier.
         */
        get: operations["getWebhook"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the decors items.
         */
        get: operations["readItemsDecors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single decors item by unique identifier.
         */
        get: operations["readSingleItemsDecors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the categories items.
         */
        get: operations["readItemsCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/categories/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single categories item by unique identifier.
         */
        get: operations["readSingleItemsCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/thickness": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the thickness items.
         */
        get: operations["readItemsThickness"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/thickness/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single thickness item by unique identifier.
         */
        get: operations["readSingleItemsThickness"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/categories_categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the categories_categories items.
         */
        get: operations["readItemsCategoriesCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/categories_categories/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single categories_categories item by unique identifier.
         */
        get: operations["readSingleItemsCategoriesCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors_categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the decors_categories items.
         */
        get: operations["readItemsDecorsCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors_categories/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single decors_categories item by unique identifier.
         */
        get: operations["readSingleItemsDecorsCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors_files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the decors_files items.
         */
        get: operations["readItemsDecorsFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors_files/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single decors_files item by unique identifier.
         */
        get: operations["readSingleItemsDecorsFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors_files_1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the decors_files_1 items.
         */
        get: operations["readItemsDecorsFiles1"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/decors_files_1/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single decors_files_1 item by unique identifier.
         */
        get: operations["readSingleItemsDecorsFiles1"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Query: {
            /**
             * @description Control what fields are being returned in the object.
             * @example [
             *       "*",
             *       "*.*"
             *     ]
             */
            fields?: string[];
            /** @example {
             *       "<field>": {
             *         "<operator>": "<value>"
             *       }
             *     } */
            filter?: Record<string, never>;
            /** @description Filter by items that contain the given search query in one of their fields. */
            search?: string;
            /**
             * @description How to sort the returned items.
             * @example [
             *       "-date_created"
             *     ]
             */
            sort?: string[];
            /** @description Set the maximum number of items that will be returned */
            limit?: number;
            /** @description How many items to skip when fetching data. */
            offset?: number;
            /** @description Cursor for use in pagination. Often used in combination with limit. */
            page?: number;
            /**
             * @description Deep allows you to set any of the other query parameters on a nested relational dataset.
             * @example {
             *       "related_articles": {
             *         "_limit": 3
             *       }
             *     }
             */
            deep?: Record<string, never>;
        };
        "x-metadata": {
            /** @description Returns the total item count of the collection you're querying. */
            total_count?: number;
            /** @description Returns the item count of the collection you're querying, taking the current filter/search parameters into account. */
            filter_count?: number;
        };
        Files: {
            /**
             * @description Unique identifier for the file.
             * @example 8cbb43fe-4cdf-4991-8352-c461779cec02
             */
            id?: string;
            /**
             * @description Name of the file on disk. By default, Directus uses a random hash for the filename.
             * @example a88c3b72-ac58-5436-a4ec-b2858531333a.jpg
             */
            filename_disk?: string;
            /**
             * @description How you want to the file to be named when it's being downloaded.
             * @example avatar.jpg
             */
            filename_download?: string;
            /**
             * @description Title for the file. Is extracted from the filename on upload, but can be edited by the user.
             * @example User Avatar
             */
            title?: string;
        };
        Flows: {
            /**
             * @description Unique identifier for the flow.
             * @example 2f24211d-d928-469a-aea3-3c8f53d4e426
             */
            id?: string;
            /**
             * @description The name of the flow.
             * @example Update Articles Flow
             */
            name?: string;
            /**
             * @description Icon displayed in the Admin App for the flow.
             * @example bolt
             */
            icon?: string;
            /**
             * @description Color of the icon displayed in the Admin App for the flow.
             * @example #112233
             */
            color?: string | null;
            description?: string | null;
            /**
             * @description Current status of the flow.
             * @default active
             * @example active
             * @enum {string}
             */
            status: "active" | "inactive";
            /**
             * @description Type of trigger for the flow. One of `hook`, `webhook`, `operation`, `schedule`, `manual`.
             * @example manual
             */
            trigger?: string;
            /**
             * @description The permission used during the flow. One of `$public`, `$trigger`, `$full`, or UUID of a role.
             * @example $trigger
             */
            accountability?: string;
            /**
             * @description Options of the selected trigger for the flow.
             * @example null
             */
            options?: Record<string, never> | null;
            /**
             * @description UUID of the operation connected to the trigger in the flow.
             * @example 92e82998-e421-412f-a513-13701e83e4ce
             */
            operation?: string;
            /**
             * Format: date-time
             * @description Timestamp in ISO8601 when the flow was created.
             * @example 2022-05-11T13:14:52Z
             */
            date_created?: string | null;
            /**
             * @description The user who created the flow.
             * @example 63716273-0f29-4648-8a2a-2af2948f6f78
             */
            user_created?: string;
            operations?: string | null;
        };
        Webhooks: {
            /**
             * @description The index of the webhook.
             * @example 1
             */
            id?: number;
            /**
             * @description The name of the webhook.
             * @example create articles
             */
            name?: string;
            /**
             * @description Method used in the webhook.
             * @example POST
             */
            method?: string;
            /**
             * @description The url of the webhook.
             * @example null
             */
            url?: string | null;
            /**
             * @description The status of the webhook.
             * @example inactive
             */
            status?: string;
            /**
             * @description If yes, send the content of what was done
             * @example true
             */
            data?: boolean;
            /**
             * @description The actions that triggers this webhook.
             * @example null
             */
            actions?: string[] | null;
            collections?: string[];
            headers?: unknown;
            was_active_before_deprecation?: boolean;
            migrated_flow?: (string | components["schemas"]["Flows"]) | null;
        };
        ItemsDecors: {
            /** Format: uuid */
            id: string;
            status?: string;
            sort?: number | null;
            /** Format: uuid */
            user_created?: string | null;
            /** Format: timestamp */
            date_created?: string | null;
            /** Format: timestamp */
            date_updated?: string | null;
            product_code?: string | null;
            brand_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            core_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            surface_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            finish_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            grain_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            texture_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            design_ref?: (string | components["schemas"]["ItemsCategories"]) | null;
            width?: number | null;
            length?: number | null;
            /** Format: float */
            depth?: number | null;
            trimming?: string | null;
            product_name?: string | null;
            b_description?: string | null;
            attachment?: (number | components["schemas"]["ItemsDecorsFiles"])[] | null;
            decor_poster?: (number | components["schemas"]["ItemsDecorsFiles1"])[] | null;
            decor_ref?: (number | components["schemas"]["ItemsDecorsCategories"])[] | null;
            thickness_ref?: (string | components["schemas"]["ItemsThickness"])[] | null;
        };
        ItemsCategories: {
            /** Format: uuid */
            id: string;
            status?: string;
            sort?: number | null;
            /** Format: uuid */
            user_created?: string | null;
            /** Format: timestamp */
            date_created?: string | null;
            /** Format: uuid */
            user_updated?: string | null;
            /** Format: timestamp */
            date_updated?: string | null;
            name?: string | null;
            parent?: (number | components["schemas"]["ItemsCategoriesCategories"])[] | null;
        };
        ItemsThickness: {
            /** Format: uuid */
            id: string;
            status?: string;
            sort?: number | null;
            /** Format: uuid */
            user_created?: string | null;
            /** Format: timestamp */
            date_created?: string | null;
            /** Format: uuid */
            user_updated?: string | null;
            /** Format: timestamp */
            date_updated?: string | null;
            /** Format: float */
            priority?: number | null;
            /** Format: float */
            thickness?: number | null;
            /** Format: float */
            length?: number | null;
            /** Format: float */
            weight?: number | null;
            /** Format: float */
            price_full_sheet?: number | null;
            /** Format: float */
            price_cutting?: number | null;
            /** Format: float */
            tax_percent?: number | null;
            in_stock?: boolean | null;
            bonded?: string | null;
            thickness_ref?: (string | components["schemas"]["ItemsDecors"]) | null;
        };
        ItemsCategoriesCategories: {
            id?: number;
            categories_id?: (string | components["schemas"]["ItemsCategories"]) | null;
            related_categories_id?: (string | components["schemas"]["ItemsCategories"]) | null;
        };
        ItemsDecorsCategories: {
            id?: number;
            decors_id?: (string | components["schemas"]["ItemsDecors"]) | null;
            categories_id?: (string | components["schemas"]["ItemsCategories"]) | null;
        };
        ItemsDecorsFiles: {
            id?: number;
            decors_id?: (string | components["schemas"]["ItemsDecors"]) | null;
            directus_files_id?: (string | components["schemas"]["Files"]) | null;
        };
        ItemsDecorsFiles1: {
            id?: number;
            decors_id?: (string | components["schemas"]["ItemsDecors"]) | null;
            directus_files_id?: (string | components["schemas"]["Files"]) | null;
        };
    };
    responses: {
        /** @description Error: Not found. */
        NotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    error?: {
                        /** Format: int64 */
                        code?: number;
                        message?: string;
                    };
                };
            };
        };
        /** @description Error: Unauthorized request */
        UnauthorizedError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    error?: {
                        /** Format: int64 */
                        code?: number;
                        message?: string;
                    };
                };
            };
        };
    };
    parameters: {
        /** @description Index */
        Id: number;
        /** @description Unique identifier for the object. */
        UUId: string;
        /** @description Collection of which you want to retrieve the items from. */
        Collection: string;
        /** @description Filter by items that contain the given search query in one of their fields. */
        Search: string;
        /** @description Cursor for use in pagination. Often used in combination with limit. */
        Page: number;
        /** @description How many items to skip when fetching data. */
        Offset: number;
        /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *      */
        Sort: string[];
        /** @description What metadata to return in the response. */
        Meta: string;
        /** @description A limit on the number of objects that are returned. */
        Limit: number;
        /** @description Select items in collection by given conditions. */
        Filter: string;
        /** @description Control what fields are being returned in the object. */
        Fields: string[];
        /** @description Saves the API response to a file. Accepts one of "csv", "json", "xml", "yaml". */
        Export: "csv" | "json" | "xml" | "yaml";
        /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
         *      */
        Version: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getAsset: {
        parameters: {
            query?: {
                /** @description The key of the asset size configured in settings. */
                key?: string;
                /** @description A JSON array of image transformations */
                transforms?: string;
                /** @description Download the asset to your computer */
                download?: boolean;
            };
            header?: never;
            path: {
                /** @description The id of the file. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            404: components["responses"]["NotFoundError"];
        };
    };
    login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Email address of the user you're retrieving the access token for.
                     * @example admin@example.com
                     */
                    email: string;
                    /**
                     * Format: password
                     * @description Password of the user.
                     * @example password
                     */
                    password: string;
                    /**
                     * @description Whether to retrieve the refresh token in the JSON response, or in a httpOnly cookie.
                     * @default json
                     * @enum {string}
                     */
                    mode?: "json" | "cookie" | "session";
                    /** @description The user's one-time-password (if MFA is enabled). */
                    otp?: string;
                };
            };
        };
        responses: {
            /** @description Successful authentification */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /** @example eyJhbGciOiJI... */
                            access_token?: string;
                            /** @example 900 */
                            expires?: number;
                            /** @example yuOJkjdPXMd... */
                            refresh_token?: string;
                        };
                    };
                };
            };
        };
    };
    refresh: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description JWT access token you want to refresh. This token can't be expired.
                     * @example eyJ0eXAiOiJKV...
                     */
                    refresh_token?: string;
                    /**
                     * @description Whether to submit and retrieve the refresh token in the JSON response, or in a httpOnly cookie.
                     * @default json
                     * @enum {string}
                     */
                    mode?: "json" | "cookie" | "session";
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /** @example eyJhbGciOiJI... */
                            access_token?: string;
                            /** @example 900 */
                            expires?: number;
                            /** @example Gy-caJMpmGTA... */
                            refresh_token?: string;
                        };
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description The refresh token to invalidate. If you have the refresh token in a cookie through /auth/login, you don't have to submit it here.
                     * @example eyJ0eXAiOiJKV...
                     */
                    refresh_token?: string;
                    /**
                     * @description Whether the refresh token is submitted in the JSON response, or in a httpOnly cookie.
                     * @enum {string}
                     */
                    mode?: "json" | "cookie" | "session";
                };
            };
        };
        responses: {
            /** @description Request successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    passwordRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Email address of the user you're requesting a reset for.
                     * @example admin@example.com
                     */
                    email: string;
                };
            };
        };
        responses: {
            401: components["responses"]["UnauthorizedError"];
        };
    };
    passwordReset: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description One-time use JWT token that is used to verify the user.
                     * @example eyJ0eXAiOiJKV1Qi...
                     */
                    token: string;
                    /**
                     * Format: password
                     * @description New password for the user.
                     * @example password
                     */
                    password: string;
                };
            };
        };
        responses: {
            401: components["responses"]["UnauthorizedError"];
        };
    };
    oauth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        public?: boolean;
                        /** @example [
                         *       "github",
                         *       "facebook"
                         *     ] */
                        data?: string[];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    oauthProvider: {
        parameters: {
            query?: {
                /** @description Where to redirect on successful login.<br/>If set the authentication details are set inside cookies otherwise a JSON is returned. */
                redirect?: string;
            };
            header?: never;
            path: {
                /** @description Key of the activated OAuth provider. */
                provider: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        public?: boolean;
                        data?: {
                            token?: string;
                        };
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    serverInfo: {
        parameters: {
            query: {
                /** @description The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in `/config/__api.json` on your server. */
                super_admin_token: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: Record<string, never>;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    ping: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/text": string;
                };
            };
        };
    };
    getFiles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Files"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getFile: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Files"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getFlows: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Flows"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getFlow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Flows"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getWebhooks: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Webhooks"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Webhooks"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsDecors: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecors"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsDecors: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecors"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsCategories: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsCategories"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsCategories: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsCategories"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsThickness: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsThickness"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsThickness: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsThickness"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsCategoriesCategories: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsCategoriesCategories"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsCategoriesCategories: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsCategoriesCategories"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsDecorsCategories: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecorsCategories"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsDecorsCategories: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecorsCategories"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsDecorsFiles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecorsFiles"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsDecorsFiles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecorsFiles"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsDecorsFiles1: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecorsFiles1"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsDecorsFiles1: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsDecorsFiles1"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
}
